import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import {
  WalletType,
  ConnectedWallet,
  createWalletAdapter,
  getAvailableWallets,
  WalletInfo,
  StellarWalletsKitAdapter,
} from '@/wallet-connector';
// ÁßªÈô§ WalletSignerProxy ÂØºÂÖ•Ôºå‰∏çÂÜç‰ΩøÁî®Â§çÊùÇÁöÑ‰ª£ÁêÜÊ®°Âºè
import { getStellarAPI } from '@/stellar';
import {
  getCurrentStellarNetwork,
  getCurrentNetworkType,
} from '@/config/stellar';
import { Horizon } from '@stellar/stellar-sdk';

export interface WalletState {
  // ËøûÊé•Áä∂ÊÄÅ
  isConnected: boolean;
  isConnecting: boolean;
  connectedWallet: ConnectedWallet | null;
  walletAdapter: StellarWalletsKitAdapter | null;

  // Ë¥¶Êà∑‰ø°ÊÅØ
  accountInfo: Horizon.AccountResponse | null;
  balances: Horizon.HorizonApi.BalanceLine[];
  xlmBalance: string;

  // ÂèØÁî®Èí±ÂåÖ
  availableWallets: WalletInfo[];

  // ÈîôËØØÁä∂ÊÄÅ
  error: string | null;

  // Âä†ËΩΩÁä∂ÊÄÅ
  isLoadingAccount: boolean;
  isLoadingBalances: boolean;
}

export interface WalletActions {
  // Èí±ÂåÖËøûÊé•
  connectWallet: (walletType: WalletType) => Promise<void>;
  disconnectWallet: () => Promise<void>;
  validateAndFixWalletConnection: () => Promise<boolean>;

  // Êï∞ÊçÆÂà∑Êñ∞
  refreshAccountInfo: () => Promise<void>;
  refreshBalances: () => Promise<void>;

  // ÈîôËØØÂ§ÑÁêÜ
  setError: (error: string | null) => void;
  clearError: () => void;

  // ÂàùÂßãÂåñ
  initializeWallets: () => void;

  // Ê®°ÊÄÅÊ°ÜÁÆ°ÁêÜ
  openWalletModal: (
    onWalletSelected?: (walletType: WalletType) => void
  ) => Promise<void>;

  // ÈáçÁΩÆÁä∂ÊÄÅ
  reset: () => void;
}

type WalletStore = WalletState & WalletActions;

const initialState: WalletState = {
  isConnected: false,
  isConnecting: false,
  connectedWallet: null,
  walletAdapter: null,
  accountInfo: null,
  balances: [],
  xlmBalance: '0',
  availableWallets: [],
  error: null,
  isLoadingAccount: false,
  isLoadingBalances: false,
};

export const useWalletStore = create<WalletStore>()(
  persist(
    (set, get) => ({
      ...initialState,

      connectWallet: async (walletType: WalletType) => {
        const { setError } = get();

        try {
          set({ isConnecting: true, error: null });

          // ÂàõÂª∫ÊàñËé∑ÂèñÈÄÇÈÖçÂô® (‰ΩøÁî®ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆÁöÑÁΩëÁªú)
          const network = getCurrentStellarNetwork();
          const adapter = createWalletAdapter(network);

          // ËøûÊé•ÊåáÂÆöÈí±ÂåÖ
          const connectedWallet = await adapter.connectWallet(walletType);

          set({
            isConnected: true,
            isConnecting: false,
            connectedWallet,
            walletAdapter: adapter,
          });

          console.log('‚úÖ Wallet connected:', {
            walletType: connectedWallet.id,
            publicKey: connectedWallet.publicKey,
          });

          // ÊâπÈáèÊõ¥Êñ∞ÊâÄÊúâ contract client ÁöÑÁ≠æÂêçÂô®
          try {
            const { updateAllClientsSignTransaction } = await import('@/states/contract-store');
            await updateAllClientsSignTransaction(adapter, connectedWallet);
            console.log('‚úÖ All clients signTransaction updated for connected wallet');
          } catch (updateError) {
            console.warn('Failed to update clients signTransaction:', updateError);
          }

          // Á´ãÂç≥Âä†ËΩΩË¥¶Êà∑‰ø°ÊÅØ
          await get().refreshAccountInfo();
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : 'Failed to connect wallet';
          setError(errorMessage);
          set({ isConnecting: false });
          throw error;
        }
      },

      disconnectWallet: async () => {
        const { walletAdapter } = get();

        try {
          if (walletAdapter) {
            await walletAdapter.disconnect();
          }
        } catch (error) {
          console.warn('Error during wallet disconnect:', error);
        } finally {
          // Ê∏ÖÈô§ÊâÄÊúâ contract client ÁöÑÁ≠æÂêçÂô®
          try {
            const { clearAllClientsSignTransaction } = await import('@/states/contract-store');
            clearAllClientsSignTransaction();
            console.log('‚úÖ All clients signTransaction cleared');
          } catch (clearError) {
            console.warn('Failed to clear clients signTransaction:', clearError);
          }

          set({
            isConnected: false,
            isConnecting: false,
            connectedWallet: null,
            walletAdapter: null,
            accountInfo: null,
            balances: [],
            xlmBalance: '0',
            error: null,
            isLoadingAccount: false,
            isLoadingBalances: false,
          });

          console.log('üîå Wallet disconnected');
        }
      },

      // Ê£ÄÊµãÂπ∂‰øÆÂ§çÈí±ÂåÖËøûÊé•Áä∂ÊÄÅ‰∏ç‰∏ÄËá¥ÈóÆÈ¢ò
      validateAndFixWalletConnection: async () => {
        const { isConnected, connectedWallet, walletAdapter } = get();

        console.log('üîç Validating wallet connection state...', {
          globalIsConnected: isConnected,
          hasConnectedWallet: !!connectedWallet,
          hasWalletAdapter: !!walletAdapter,
          walletAdapterIsConnected: walletAdapter?.isConnected?.(),
        });

        // Ê£ÄÊµãÁä∂ÊÄÅ‰∏ç‰∏ÄËá¥ÔºöÂÖ®Â±ÄÁä∂ÊÄÅËØ¥Â∑≤ËøûÊé•Ôºå‰ΩÜÈÄÇÈÖçÂô®ËØ¥Êú™ËøûÊé•
        if (isConnected && connectedWallet && walletAdapter && !walletAdapter.isConnected?.()) {
          console.log('‚ö†Ô∏è Detected wallet state inconsistency after page refresh');
          console.log('üîÑ Attempting to re-establish wallet connection...');

          try {
            // Â∞ùËØïÈáçÊñ∞ËøûÊé•Áõ∏ÂêåÁöÑÈí±ÂåÖ
            const { connectWallet } = get();
            await connectWallet(connectedWallet.id as any);
            console.log('‚úÖ Wallet connection re-established successfully');
            return true;
          } catch (reconnectError) {
            console.error('‚ùå Failed to re-establish wallet connection:', reconnectError);
            // Ê∏ÖÈô§‰∏ç‰∏ÄËá¥ÁöÑÁä∂ÊÄÅ
            const { disconnectWallet } = get();
            await disconnectWallet();
            return false;
          }
        }

        // Áä∂ÊÄÅ‰∏ÄËá¥ÔºåÊó†ÈúÄÂ§ÑÁêÜ
        if (isConnected && connectedWallet && walletAdapter?.isConnected?.()) {
          console.log('‚úÖ Wallet connection state is consistent');
          return true;
        }

        // ÂÖ®Â±ÄÁä∂ÊÄÅËØ¥Êú™ËøûÊé•ÔºåËøôÊòØÊ≠£Â∏∏ÁöÑ
        if (!isConnected) {
          console.log('‚ÑπÔ∏è Wallet is not connected (normal state)');
          return false;
        }

        return false;
      },

      refreshAccountInfo: async () => {
        const { connectedWallet, setError } = get();

        if (!connectedWallet) {
          setError('No wallet connected');
          return;
        }

        try {
          set({ isLoadingAccount: true, error: null });

          const stellarAPI = getStellarAPI();
          const accountInfo = await stellarAPI.getAccount(
            connectedWallet.publicKey
          );

          set({
            accountInfo,
            isLoadingAccount: false,
          });

          // ÂêåÊó∂Âà∑Êñ∞‰ΩôÈ¢ù
          await get().refreshBalances();
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : 'Failed to load account info';
          console.error('‚ùå Failed to load account info:', errorMessage);
          setError(errorMessage);
          set({ isLoadingAccount: false });
        }
      },

      refreshBalances: async () => {
        const { connectedWallet, setError } = get();

        if (!connectedWallet) {
          setError('No wallet connected');
          return;
        }

        try {
          set({ isLoadingBalances: true, error: null });

          const stellarAPI = getStellarAPI();
          const balances = await stellarAPI.getAccountBalances(
            connectedWallet.publicKey
          );
          const xlmBalance = await stellarAPI.getXLMBalance(
            connectedWallet.publicKey
          );

          const networkType = getCurrentNetworkType();
          console.log(`üí∞ Balances loaded for ${networkType}:`, {
            publicKey: connectedWallet.publicKey,
            xlmBalance,
            totalBalances: balances.length,
            network: stellarAPI.isTestnet() ? 'Testnet' : 'Mainnet',
            horizonUrl: stellarAPI.getConfig().horizonUrl,
          });

          set({
            balances,
            xlmBalance,
            isLoadingBalances: false,
          });
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : 'Failed to load balances';
          console.error('‚ùå Failed to load balances:', errorMessage);
          setError(errorMessage);
          set({ isLoadingBalances: false });
        }
      },

      setError: (error: string | null) => {
        set({ error });
      },

      clearError: () => {
        set({ error: null });
      },

      initializeWallets: async () => {
        const network = getCurrentStellarNetwork();
        const adapter = createWalletAdapter(network);
        const availableWallets = await getAvailableWallets(adapter.getKit());
        set({ availableWallets, walletAdapter: adapter });
      },

      openWalletModal: async (
        onWalletSelected?: (walletType: WalletType) => void
      ) => {
        const { walletAdapter, connectWallet, setError } = get();

        // Â¶ÇÊûú walletAdapter ‰∏çÂ≠òÂú®ÔºåÈáçÊñ∞ÂàõÂª∫‰∏Ä‰∏™
        let adapter = walletAdapter;
        if (!adapter) {
          try {
            const network = getCurrentStellarNetwork();
            adapter = createWalletAdapter(network);
            set({ walletAdapter: adapter });
          } catch (error) {
            setError('Failed to initialize wallet adapter');
            return;
          }
        }

        try {
          await adapter.openModal({
            onWalletSelected: async (walletType: WalletType) => {
              try {
                await connectWallet(walletType);
                if (onWalletSelected) {
                  onWalletSelected(walletType);
                }
              } catch (error) {
                console.error('Failed to connect wallet from modal:', error);
              }
            },
            onClosed: (error?: Error) => {
              if (error) {
                setError(error.message);
              }
            },
            modalTitle: 'Connect Your Wallet',
            notAvailableText:
              'Wallet not available. Please install the wallet extension.',
          });
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : 'Failed to open wallet modal';
          setError(errorMessage);
        }
      },

      reset: () => {
        set(initialState);
      },
    }),
    {
      name: 'stellar-wallet-storage',
      partialize: state => ({
        // Âè™ÊåÅ‰πÖÂåñÂøÖË¶ÅÁöÑÁä∂ÊÄÅ
        connectedWallet: state.connectedWallet,
        isConnected: state.isConnected,
      }),
    }
  )
);

// ËÆ¢ÈòÖÂô®Áî®‰∫éËá™Âä®Âà∑Êñ∞Êï∞ÊçÆ
let refreshInterval: NodeJS.Timeout | null = null;

// ÂêØÂä®Ëá™Âä®Âà∑Êñ∞
export const startAutoRefresh = (intervalMs: number = 30000) => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
  }

  refreshInterval = setInterval(() => {
    const { isConnected, refreshBalances } = useWalletStore.getState();
    if (isConnected) {
      refreshBalances();
    }
  }, intervalMs);
};

// ÂÅúÊ≠¢Ëá™Âä®Âà∑Êñ∞
export const stopAutoRefresh = () => {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
};

// ÁõëÂê¨Èí±ÂåÖËøûÊé•Áä∂ÊÄÅÂèòÂåñ
let previousConnected = false;
useWalletStore.subscribe(state => {
  if (state.isConnected !== previousConnected) {
    if (state.isConnected) {
      startAutoRefresh();
    } else {
      stopAutoRefresh();
    }
    previousConnected = state.isConnected;
  }
});
